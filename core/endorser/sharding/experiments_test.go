package sharding_test

import (
	"context"
	"fmt"
	"math/rand"
	"sync"
	"testing"
	"time"

	"github.com/hyperledger/fabric/core/endorser/sharding"
	"go.etcd.io/etcd/raft/v3/raftpb"
)

// Network simulates the network between Raft nodes
type Network struct {
	nodes   map[uint64]*sharding.ShardLeader
	latency time.Duration
	loss    float64 // Probability of packet loss (0.0 - 1.0)
	mu      sync.RWMutex
}

func NewNetwork(latency time.Duration, loss float64) *Network {
	return &Network{
		nodes:   make(map[uint64]*sharding.ShardLeader),
		latency: latency,
		loss:    loss,
	}
}

func (n *Network) AddNode(id uint64, node *sharding.ShardLeader) {
	n.mu.Lock()
	defer n.mu.Unlock()
	n.nodes[id] = node
}

func (n *Network) Run() {
	// In a real implementation, this would start a background router.
	// For this test, nodes push to the network via helper methods.
}

func (n *Network) RouteMessages(fromID uint64, msgs []raftpb.Message) {
	n.mu.RLock()
	defer n.mu.RUnlock()

	for _, msg := range msgs {
		msg := msg // copy
		// Simulate packet loss
		if n.loss > 0 && rand.Float64() < n.loss {
			continue
		}

		target := n.nodes[msg.To]
		if target == nil {
			continue
		}

		// Simulate latency
		go func(t *sharding.ShardLeader, m raftpb.Message) {
			if n.latency > 0 {
				time.Sleep(n.latency)
			}
			t.Step(context.TODO(), m)
		}(target, msg)
	}
}

func TestExperiments(t *testing.T) {
	// Fault tolerance levels to test: f=0, 1, 2, 3, 4, 5
	// N = 2f + 1
	fs := []int{0, 1, 2, 3, 4, 5}
	
	// Experiment parameters
	duration := 10 * time.Second
	txCount := 1000 // Total transactions to attempt per experiment
	
	fmt.Printf("Starting Sharded Raft Experiments\n")
	fmt.Printf("=================================\n")
	fmt.Printf("%-5s %-5s %-15s %-15s %-15s\n", "f", "Nodes", "Throughput(tx/s)", "AvgLatency(ms)", "SuccessRate(%)")

	for _, f := range fs {
		runExperiment(t, f, txCount, duration)
	}
}

func runExperiment(t *testing.T, f int, txCount int, duration time.Duration) {
	n := 2*f + 1
	nodes := make([]*sharding.ShardLeader, n)
	net := NewNetwork(5*time.Millisecond, 0.0) // 5ms latency, 0% loss (ideal network)

	// Create nodes
	replicaNodes := make([]string, n)
	for i := 0; i < n; i++ {
		replicaNodes[i] = fmt.Sprintf("node%d", i+1)
	}

	for i := 0; i < n; i++ {
		config := sharding.ShardConfig{
			ShardID:      "experiment-shard",
			ReplicaNodes: replicaNodes,
			ReplicaID:    uint64(i + 1),
		}
		
		node, err := sharding.NewShardLeader(config, 100*time.Millisecond, 50) // Tuning for test
		if err != nil {
			t.Fatalf("Failed to create node %d: %v", i+1, err)
		}
		nodes[i] = node
		net.AddNode(uint64(i+1), node)
		
		// Start message router for this node
		go func(node *sharding.ShardLeader, id uint64) {
			for msgs := range node.MessagesC() {
				net.RouteMessages(id, msgs)
			}
		}(node, uint64(i+1))
	}

	// Wait for leader election
	// We just push some traffic to trigger it, simple wait
	time.Sleep(2 * time.Second)

	// Run workload
	var wg sync.WaitGroup
	startTime := time.Now()
	successCount := 0
	var mu sync.Mutex

	// Send transactions to ANY node (simulating clients hitting random endorsers)
	// In Raft, followers forward to leader. etcd/raft handles this via MsgProp.
	
	workloadCh := make(chan int, txCount)
	for i := 0; i < txCount; i++ {
		workloadCh <- i
	}
	close(workloadCh)

	// Simulate client threads
	clientCount := 10
	for c := 0; c < clientCount; c++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for i := range workloadCh {
				// Pick random node
				nodeID := rand.Intn(n)
				node := nodes[nodeID]

				req := &sharding.PrepareRequest{
					TxID:      fmt.Sprintf("tx-%d-%d", f, i),
					ShardID:   "experiment-shard",
					WriteSet:  map[string][]byte{"key": []byte("value")},
					Timestamp: time.Now(),
				}

				// Send to node
				// Note: ProposeC might block if full, so we select
				select {
				case node.ProposeC() <- req:
					// Request sent
				case <-time.After(500 * time.Millisecond):
					// Send timeout
				}
			}
		}()
	}

	// Monitor Commit Channels of all nodes (or just Leader? Proofs are generated by leader)
	// We want to count how many UNIQUE transactions are committed.
	committedTxs := make(map[string]bool)
	
	// Create a merged channel for all commit streams
	allCommits := make(chan *sharding.PrepareProof, 10000)
	for _, node := range nodes {
		go func(c <-chan *sharding.PrepareProof) {
			for proof := range c {
				allCommits <- proof
			}
		}(node.CommitC())
	}

	// Run for duration or until done
	timeout := time.After(duration)
	
Loop:
	for {
		select {
		case proof := <-allCommits:
			mu.Lock()
			if !committedTxs[proof.TxID] {
				committedTxs[proof.TxID] = true
				successCount++
			}
			mu.Unlock()
			if successCount >= txCount {
				break Loop
			}
		case <-timeout:
			break Loop
		}
	}

	elapsed := time.Since(startTime)
	if elapsed > duration {
		elapsed = duration
	}

	throughput := float64(successCount) / elapsed.Seconds()
    // Avoid division by zero
	
	fmt.Printf("%-5d %-5d %-15.2f %-15s %-15.2f\n", f, n, throughput, "N/A", float64(successCount)/float64(txCount)*100)

	// Cleanup
	for _, node := range nodes {
		node.Stop()
	}
}
